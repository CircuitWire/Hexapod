# -*- coding: utf-8 -*-
"""pathDetermination.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1FopVKB-urIS_Y4cvKUUDl4dOAkgG7alf
"""

import math
import numpy as np
import matplotlib.pyplot as plt

#convert degree input to radian output
def degreeToRadian(degree):
  return degree * (np.pi/180)

#convert radian input to degree output
def radianToDegree(radian):
  return radian * (180/np.pi)

#calculates distance between two points
def calcSide(p1,p2):
  #print(p1, p2)
  return (((p2[0]-p1[0])**2) + ((p2[1]-p1[1])**2))**(1/2)





def vectorFromPoints(p2, p1):
  return [p2[0] - p1[0], p2[1] - p1[1]]

def angleFromVectors(v1, v2):
  #θ = arccos((v1•v2)/(|v1||v2))
  #print(v1, v2)
  
  return radianToDegree(np.arccos((v1[0]*v2[0]+v1[1]*v2[1])/(calcSide(v1,[0,0])*calcSide(v2,[0,0]))))

def calcAngleOrient(target, start, turn):
  centroid = calcCentroid(target, start, turn)

  targetVector = vectorFromPoints(target, centroid)
  startVector = vectorFromPoints(start, centroid)
  turnVector = vectorFromPoints(turn, centroid)

  startAngle = radianToDegree(np.arctan2(startVector[1], startVector[0]))
  if  startAngle < 0:
    startAngle = 360 + startAngle

  targetAngle = radianToDegree(np.arctan2(targetVector[1], targetVector[0]))
  if targetAngle < 0:
    targetAngle = 360 + targetAngle

  turnAngle = radianToDegree(np.arctan2(turnVector[1], turnVector[0]))
  if turnAngle <0:
    turnAngle = 360 + turnAngle

  if ((startAngle < targetAngle and targetAngle < turnAngle) or (targetAngle < turnAngle and turnAngle < startAngle) or (turnAngle < startAngle and startAngle < targetAngle)):
    return -calculateAngle(target, start, turn)
  else:
    return calculateAngle(target, start, turn)





  #theta = radianToDegree(np.arctan2(targetVector[1], targetVector[0])) - radianToDegree(np.arctan2(startVector[1], startVector[0]))
  #phi  = radianToDegree(np.arctan2(targetVector[1], targetVector[0])) - radianToDegree(np.arctan2(turnVector[1], turnVector[0]))

  print(startAngle)
  print(targetAngle)
  print(turnAngle)

  #print(theta)
  #print(phi)

calcAngleOrient(target, start, turn)

#calculates angle orientation for hexapod
def detOrientedAngle(target, start, turn):

  angle = calculateAngle(target, start, turn)

  if start[0] == target[0]:
    if start[0] < turn[0]:
      print("case 1")
      return angle
    else:
      print("case 2")
      return -angle
  elif start[1] == target[1]:
    if start[1] > turn[1]:
      print("case 3")
      return angle
    else:
      print("case 4")
      return -angle
  elif (start[1] < target[1] and start[0] > turn[0]) or (start[1] > target[1] and start[0] < turn[0]):
    print("case 5")
    return angle
  else:
    print("case 6")
    return -angle

def calculatePath(target, start, turn):
  angle = calcAngleOrient(target, start, turn)
  d = calcSide(turn, target)

  return angle, d

angle, d = calculatePath([5,0], [0,10], [10,10])

print(angle, d)

angle, d = calculatePath([100,100], [0,0], [6,0])

print(angle, d)

target = [0,10]
start = [5,0]
turn = [-5,6]
centroid = calcCentroid(target, start, turn)

print(angleFromVectors( [start[0]-centroid[0],start[1]-centroid[1]], [target[0]-centroid[0],target[1]-centroid[1]]))

#angle = atan2(vector2.y, vector2.x) - atan2(vector1.y, vector1.x)

ta = vectorFromPoints(target, centroid)
st = vectorFromPoints(start, centroid)
tu = vectorFromPoints(turn, centroid)
print(st)

#np.arctan2(y, x)
#theta = radianToDegree(np.arctan2(tu[1], tu[0])) - radianToDegree(np.arctan2(ta[1], ta[0]))
theta = radianToDegree(np.arctan2(1, 0)) - radianToDegree(np.arctan2(-1, 100))
print(theta)
#phi = radianToDegree(np.arctan2(tu, st))
#print(phi)